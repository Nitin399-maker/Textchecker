<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Spell Check & Decimal Validator</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTUiIGZpbGw9IiMyNTYzZWIiLz48cGF0aCBmaWxsPSIjZmZmIiBkPSJtMTYgNyAyIDcgNyAyLTcgMi0yIDctMi03LTctMiA3LTJaIi8+PC9zdmc+" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <style>
        body { margin-bottom: 50vh; }
        .narrative { max-inline-size: 40rem; }
        .demo-card { 
            transition: all 0.2s ease; 
            border: 1px solid var(--bs-border-color); 
            cursor: pointer;
        }
        .demo-card:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); 
            border-color: var(--bs-primary); 
        }
        .demo-card.border-primary { 
            border-color: var(--bs-primary) !important; 
            box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25); 
        }
        #dropArea { 
            cursor: pointer; 
            transition: all 0.3s ease; 
            min-height: 200px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
        }
        #imagePreview img { max-height: 300px; max-width: 100%; }
        .spinner-border-sm { width: 1rem; height: 1rem; }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg bg-body-tertiary" data-bs-theme="dark">
        <div class="container-fluid">
            <a class="navbar-brand" href=".">OCR Checker</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <div class="nav-item dropdown ms-auto">
                    <button class="dark-theme-toggle btn btn-outline-light dropdown-toggle" type="button" data-bs-toggle="dropdown">
                        <i class="bi bi-circle-half"></i> <span class="d-lg-none ms-2">Toggle theme</span>
                    </button>
                    <ul class="dropdown-menu dropdown-menu-end">
                        <li><button class="dropdown-item" data-bs-theme-value="light"><i class="me-2 bi bi-sun-fill"></i> Light</button></li>
                        <li><button class="dropdown-item" data-bs-theme-value="dark"><i class="me-2 bi bi-moon-stars-fill"></i> Dark</button></li>
                        <li><button class="dropdown-item" data-bs-theme-value="auto"><i class="me-2 bi bi-circle-half"></i> Auto</button></li>
                    </ul>
                </div>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <h1 class="display-1 my-4 text-center">OCR Checker</h1>
        <h2 class="display-6 text-center">Extract text, check <em>spelling</em> & validate decimals</h2>
        
        <div class="mx-auto my-3 narrative">
            <p class="mb-2">Upload images to extract text using OCR, automatically detect spelling errors and decimal formatting issues.</p>
            <ul class="mb-0">
                <li>Extract text from images using advanced AI vision models</li>
                <li>AI-powered error detection combined with Typo.js for comprehensive spell checking</li>
                <li>Find decimal comma errors and convert to proper decimal points</li>
                <li>Generate interactive PDF reports with clickable comment annotations</li>
            </ul>
        </div>

        <div class="my-4">
            <h3 class="h5 mb-3 text-center">Common Use Cases</h3>
            <div id="demo-cards" class="row g-3">
                <div class="col-md-6 col-lg-4">
                    <div class="card h-100 demo-card" data-demo-type="document">
                        <div class="card-body">
                            <h6 class="card-title"><i class="bi bi-file-text me-2"></i>Document Scanning</h6>
                            <p class="card-text small text-muted">Scan typed documents, reports, and forms for text extraction and error checking</p>
                        </div>
                    </div>
                </div>
                <div class="col-md-6 col-lg-4">
                    <div class="card h-100 demo-card" data-demo-type="handwritten">
                        <div class="card-body">
                            <h6 class="card-title"><i class="bi bi-pencil me-2"></i>Handwritten Notes</h6>
                            <p class="card-text small text-muted">Extract text from handwritten notes and check for spelling errors</p>
                        </div>
                    </div>
                </div>
                <div class="col-md-6 col-lg-4">
                    <div class="card h-100 demo-card" data-demo-type="financial">
                        <div class="card-body">
                            <h6 class="card-title"><i class="bi bi-calculator me-2"></i>Financial Documents</h6>
                            <p class="card-text small text-muted">Process invoices, receipts, and financial documents with decimal validation</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="accordion my-4">
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#advanced-settings">
                        <i class="bi bi-sliders2 me-2"></i> LLM Configuration & Settings
                    </button>
                </h2>
                <div id="advanced-settings" class="accordion-collapse collapse">
                    <div class="accordion-body">
                        <div class="row mb-3">
                            <div class="col">
                                <button id="config-btn" class="btn btn-outline-primary">
                                    <i class="bi bi-gear me-1"></i> Config LLM
                                </button>
                                <select id="model-select" class="form-select d-inline-block ms-2" style="width: 280px;">
                                    <option value="gpt-4o-mini" selected>GPT-4o Mini</option>
                                    <option value="google/gemini-2.5-pro">Gemini 2.5 Pro</option>
                                    <option value="openai/gpt-4.1-mini">GPT-4.1 Mini</option>
                                    <option value="gpt-4.1">GPT-4.1</option>
                                    <option value="google/gemini-2.5-flash-preview-09-2025">Gemini 2.5 Flash</option>
                                    <option value="google/gemini-3-flash-preview">Gemini 3 Flash</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="mb-3">
            <label for="imageInput" class="form-label">Upload Image for OCR Processing:</label>
            <input type="file" class="form-control d-none" id="imageInput" accept="image/*">
            
            <div id="dropArea" class="border border-dashed border-3 border-secondary rounded p-5 mb-3">
                <i class="bi bi-cloud-upload fs-1 text-muted"></i>
                <p class="mt-3 mb-2 h5">Drag and drop an image here or click to browse</p>
                <p class="text-muted small">Supported formats: BMP, GIF, TIFF, JPEG, PNG, EPS, WEBP</p>
            </div>

            <div class="mt-2">
                <button id="processBtn" class="btn btn-primary" disabled>
                    <i class="bi bi-play-circle me-2"></i>Process Image
                </button>
                <button id="btn-new-process" class="btn btn-outline-secondary d-none">
                    üÜï Process New Image
                </button>
            </div>
        </div>

        <div id="preview-container" class="d-none">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5><i class="bi bi-eye me-2"></i>Image Preview</h5>
                    <button id="downloadBtn" class="btn btn-success d-none">
                        <i class="bi bi-download me-2"></i>Download Interactive PDF
                    </button>
                </div>
                <div class="card-body">
                    <div id="imagePreview" class="text-center"></div>
                </div>
            </div>
        </div>

        <div id="results-container" class="d-none">
            <div class="card mt-4">
                <div class="card-header">
                    <h5><i class="bi bi-file-text me-2"></i>OCR Results & Analysis</h5>
                </div>
                <div class="card-body">
                    <div id="results-content"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modals -->
    <div class="modal fade" id="correctionModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header bg-primary text-white">
                    <h5 class="modal-title"><i class="bi bi-pencil-square me-2"></i>Correction Suggestion</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="row">
                        <div class="col-6">
                            <h6 class="text-danger fw-bold">Original:</h6>
                            <div id="originalText" class="p-3 bg-danger bg-opacity-10 border border-danger rounded"></div>
                        </div>
                        <div class="col-6">
                            <h6 class="text-success fw-bold">Suggested:</h6>
                            <div id="suggestedText" class="p-3 bg-success bg-opacity-10 border border-success rounded"></div>
                        </div>
                    </div>
                    <div class="mt-3 p-3 bg-info bg-opacity-10 rounded">
                        <p class="mb-0"><strong>Issue Type:</strong> <span id="issueType" class="badge bg-info"></span></p>
                        <p class="mb-0 mt-2"><strong>Source:</strong> <span id="issueSource" class="badge bg-secondary"></span></p>
                        <p class="mb-0 mt-2"><strong>Description:</strong> <span id="issueDescription"></span></p>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-danger" id="rejectBtn">
                        <i class="bi bi-x-circle me-2"></i>Reject
                    </button>
                    <button type="button" class="btn btn-success" id="acceptBtn">
                        <i class="bi bi-check-circle me-2"></i>Accept
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal fade" id="progressModal" tabindex="-1" data-bs-backdrop="static">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header bg-info text-white">
                    <h5 class="modal-title"><i class="bi bi-gear me-2"></i>Processing</h5>
                </div>
                <div class="modal-body text-center">
                    <div class="spinner-border text-primary mb-3" style="width: 3rem; height: 3rem;"></div>
                    <p id="progressText" class="mb-0">Processing image...</p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@gramex/ui@0.3.1/dist/dark-theme.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap-llm-provider@1.2/dist/bootstrap-llm-provider.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap-alert@1/dist/bootstrap-alert.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/cfinke/Typo.js/typo/typo.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    
    <script>
        class OCRSpellChecker {
            constructor() {
                // Core state
                this.state = {
                    uploadedImage: null,
                    extractedText: '',
                    detectedIssues: [],
                    acceptedCorrections: [],
                    currentIssueIndex: 0,
                    originalImageBase64: null,
                    currentModel: "gpt-4o-mini"
                };
                
                // Components
                this.dictionary = null;
                this.progressModal = null;
                this.llmProvider = null;
                
                // Cache DOM elements
                this.elements = this.cacheElements();
                
                this.init();
            }

            cacheElements() {
                const $ = id => document.getElementById(id);
                return {
                    imageInput: $('imageInput'),
                    dropArea: $('dropArea'),
                    processBtn: $('processBtn'),
                    downloadBtn: $('downloadBtn'),
                    newProcessBtn: $('btn-new-process'),
                    modelSelect: $('model-select'),
                    configBtn: $('config-btn'),
                    imagePreview: $('imagePreview'),
                    previewContainer: $('preview-container'),
                    resultsContainer: $('results-container'),
                    resultsContent: $('results-content'),
                    progressText: $('progressText'),
                    originalText: $('originalText'),
                    suggestedText: $('suggestedText'),
                    issueType: $('issueType'),
                    issueSource: $('issueSource'),
                    issueDescription: $('issueDescription'),
                    acceptBtn: $('acceptBtn'),
                    rejectBtn: $('rejectBtn'),
                    demoCards: $('demo-cards')
                };
            }

            async init() {
                await this.initSpellChecker();
                this.setupEventListeners();
                await this.initLLMProvider();
            }

            // LLM Provider Integration
            async initLLMProvider() {
                try {
                    const { openaiConfig } = await import('https://cdn.jsdelivr.net/npm/bootstrap-llm-provider@1.2/+esm');
                    
                    this.llmProvider = {
                        config: null,
                        async getConfig(show = false) {
                            if (!this.config || show) {
                                this.config = await openaiConfig({
                                    title: "OCR LLM Configuration",
                                    defaultBaseUrls: [
                                        "https://api.openai.com/v1", 
                                        "https://openrouter.ai/api/v1",
                                        "https://api.anthropic.com/v1"
                                    ],
                                    show
                                });
                            }
                            return this.config;
                        }
                    };
                } catch (error) {
                    console.warn('LLM provider initialization failed:', error);
                    this.showAlert('LLM provider not available. Please configure manually.', 'warning');
                }
            }

            async initSpellChecker() {
                try {
                    const [affData, dicData] = await Promise.all([
                        this.fetchFile("en_US.aff").catch(() => null),
                        this.fetchFile("en_US.dic").catch(() => null)
                    ]);
                    
                    if (affData && dicData) {
                        this.dictionary = new Typo("en_US", affData, dicData);
                        console.log('Typo.js spell checker initialized');
                    }
                } catch (error) {
                    console.warn('Typo.js initialization failed, continuing with AI-only spell checking');
                }
            }

            async fetchFile(path) {
                const response = await fetch(path);
                if (!response.ok) throw new Error(`Failed to fetch ${path}`);
                return response.text();
            }

            setupEventListeners() {
                const { elements } = this;
                
                // File handling
                elements.imageInput.addEventListener('change', e => this.handleFileSelect(e));
                elements.dropArea.addEventListener('click', () => elements.imageInput.click());
                elements.dropArea.addEventListener('dragover', e => this.handleDragOver(e));
                elements.dropArea.addEventListener('dragleave', e => this.handleDragLeave(e));
                elements.dropArea.addEventListener('drop', e => this.handleDrop(e));

                // Demo cards
                elements.demoCards.addEventListener('click', e => this.handleDemoCardClick(e));

                // Process buttons
                elements.processBtn.addEventListener('click', () => this.processImage());
                elements.downloadBtn.addEventListener('click', () => this.downloadPDF());
                elements.newProcessBtn.addEventListener('click', () => this.resetApp());

                // Configuration
                elements.configBtn.addEventListener('click', () => this.configLLM());
                elements.modelSelect.addEventListener('change', e => {
                    this.state.currentModel = e.target.value;
                });

                // Correction modal
                elements.acceptBtn.addEventListener('click', () => this.acceptCorrection());
                elements.rejectBtn.addEventListener('click', () => this.rejectCorrection());
            }

            // Utility methods
            showElements(...ids) {
                ids.forEach(id => {
                    const el = typeof id === 'string' ? document.getElementById(id) : id;
                    if (el) el.classList.remove('d-none');
                });
            }

            hideElements(...ids) {
                ids.forEach(id => {
                    const el = typeof id === 'string' ? document.getElementById(id) : id;
                    if (el) el.classList.add('d-none');
                });
            }

            showAlert(message, type = 'info') {
                if (typeof bootstrapAlert !== 'undefined') {
                    bootstrapAlert({ body: message, color: type });
                } else {
                    // Fallback to basic alert
                    const alertDiv = document.createElement('div');
                    alertDiv.className = `alert alert-${type} alert-dismissible fade show mt-3`;
                    alertDiv.innerHTML = `${message}<button type="button" class="btn-close" data-bs-dismiss="alert"></button>`;
                    document.querySelector('.container').appendChild(alertDiv);
                    setTimeout(() => alertDiv.remove(), 5000);
                }
            }

            setButtonState(button, loading = false, text = '') {
                if (loading) {
                    button.disabled = true;
                    button.dataset.originalText = button.innerHTML;
                    button.innerHTML = `<span class="spinner-border spinner-border-sm me-2"></span>${text}`;
                } else {
                    button.disabled = false;
                    button.innerHTML = button.dataset.originalText || text;
                }
            }

            // Utility function to sanitize text for PDF compatibility
            sanitizeTextForPDF(text) {
                if (!text) return '';
                
                return text
                    // Replace Unicode arrows and special characters with ASCII equivalents
                    .replace(/‚Üí/g, '->')
                    .replace(/‚Üê/g, '<-')
                    .replace(/‚Üë/g, '^')
                    .replace(/‚Üì/g, 'v')
                    .replace(/‚úì/g, 'OK')
                    .replace(/‚úó/g, 'X')
                    .replace(/‚Ä¢/g, '*')
                    .replace(/‚Äì/g, '-')
                    .replace(/‚Äî/g, '--')
                    .replace(/"/g, '"')
                    .replace(/"/g, '"')
                    .replace(/'/g, "'")
                    .replace(/'/g, "'")
                    .replace(/‚Ä¶/g, '...')
                    .replace(/¬©/g, '(c)')
                    .replace(/¬Æ/g, '(R)')
                    .replace(/‚Ñ¢/g, '(TM)')
                    .replace(/¬∞/g, 'deg')
                    .replace(/¬±/g, '+/-')
                    .replace(/‚âà/g, '~=')
                    .replace(/‚â§/g, '<=')
                    .replace(/‚â•/g, '>=')
                    .replace(/‚â†/g, '!=')
                    .replace(/√ó/g, 'x')
                    .replace(/√∑/g, '/')
                    // Remove any remaining non-ASCII characters (keep only printable ASCII)
                    .replace(/[^\x20-\x7E]/g, '?');
            }

            // Event handlers
            handleDemoCardClick(event) {
                const card = event.target.closest(".demo-card");
                if (!card) return;

                const demoType = card.dataset.demoType;
                const messages = {
                    'document': 'Upload a document image for professional text extraction',
                    'handwritten': 'Upload handwritten notes for OCR processing', 
                    'financial': 'Upload financial documents to detect decimal formatting issues'
                };

                // Visual feedback
                document.querySelectorAll(".demo-card").forEach(c => c.classList.remove("border-primary"));
                card.classList.add("border-primary");

                // Update drop area temporarily
                const originalHTML = this.elements.dropArea.innerHTML;
                this.elements.dropArea.innerHTML = `
                    <i class="bi bi-cloud-upload fs-1 text-primary"></i>
                    <p class="mt-3 mb-2 h5 text-primary">${messages[demoType]}</p>
                    <p class="text-muted small">Click here to upload your ${demoType} image</p>
                `;

                setTimeout(() => {
                    this.elements.dropArea.innerHTML = originalHTML;
                    card.classList.remove("border-primary");
                }, 3000);

                this.elements.dropArea.scrollIntoView({ behavior: "smooth", block: "center" });
            }

            handleFileSelect(event) {
                const file = event.target.files[0];
                if (file) this.validateAndProcessFile(file);
            }

            handleDragOver(event) {
                event.preventDefault();
                this.elements.dropArea.classList.add('border-primary', 'bg-primary', 'bg-opacity-10');
            }

            handleDragLeave(event) {
                event.preventDefault();
                this.elements.dropArea.classList.remove('border-primary', 'bg-primary', 'bg-opacity-10');
            }

            handleDrop(event) {
                event.preventDefault();
                this.elements.dropArea.classList.remove('border-primary', 'bg-primary', 'bg-opacity-10');
                
                const files = Array.from(event.dataTransfer.files);
                if (files.length > 0) this.validateAndProcessFile(files[0]);
            }

            validateAndProcessFile(file) {
                const allowedTypes = ['image/bmp', 'image/gif', 'image/tiff', 'image/jpeg', 'image/jpg', 'image/png', 'image/eps', 'image/webp'];
                
                if (!allowedTypes.includes(file.type) && !file.type.startsWith('image/')) {
                    this.showAlert('Only image formats are allowed.', 'danger');
                    return;
                }

                this.state.uploadedImage = file;
                this.displayImagePreview(file);
                this.elements.processBtn.disabled = false;
            }

            displayImagePreview(file) {
                const reader = new FileReader();
                reader.onload = e => {
                    this.state.originalImageBase64 = e.target.result;
                    this.elements.imagePreview.innerHTML = `
                        <img src="${e.target.result}" class="img-fluid rounded shadow" alt="Uploaded image">
                        <p class="mt-2 text-muted small">${file.name}</p>
                    `;
                };
                reader.readAsDataURL(file);
                this.showElements(this.elements.previewContainer);
            }

            async configLLM() {
                if (this.llmProvider) {
                    try {
                        await this.llmProvider.getConfig(true);
                        this.showAlert('LLM configuration updated successfully', 'success');
                    } catch (error) {
                        this.showAlert('LLM configuration failed', 'danger');
                    }
                } else {
                    this.showAlert('LLM provider not available', 'warning');
                }
            }

            // Core processing - SINGLE API CALL
            async processImage() {
                if (!this.llmProvider) {
                    this.showAlert('Please configure LLM first', 'warning');
                    return;
                }

                let config;
                try {
                    config = await this.llmProvider.getConfig();
                } catch (error) {
                    this.showAlert('Please configure LLM first', 'warning');
                    return;
                }

                this.setButtonState(this.elements.processBtn, true, 'Processing...');
                this.showProgressModal();

                try {
                    this.updateProgress('Extracting text and detecting errors with AI...');
                    
                    // SINGLE API CALL for both text extraction and error detection
                    const aiResults = await this.extractTextAndDetectErrors(config);
                    
                    this.updateProgress('Validating with Typo.js spell checker...');
                    
                    // Additional validation with Typo.js
                    const typoIssues = this.validateWithTypoJS(aiResults.text);
                    
                    // Merge and deduplicate issues
                    this.state.detectedIssues = this.mergeIssues(aiResults.issues, typoIssues);
                    this.state.extractedText = aiResults.text;
                    
                    this.displayResults();
                    this.hideProgressModal();
                    
                    if (this.state.detectedIssues.length > 0) {
                        this.state.currentIssueIndex = 0;
                        this.state.acceptedCorrections = [];
                        this.showNextCorrection();
                    } else {
                        this.showElements(this.elements.downloadBtn);
                        this.showAlert('No spelling or decimal issues found! ‚úÖ', 'success');
                    }
                    
                    this.showElements(this.elements.newProcessBtn);
                    
                } catch (error) {
                    this.hideProgressModal();
                    this.showAlert(`Processing failed: ${error.message}`, 'danger');
                } finally {
                    this.setButtonState(this.elements.processBtn, false, '<i class="bi bi-play-circle me-2"></i>Process Image');
                }
            }

            // SINGLE API CALL - Extract text and detect errors in one go
            async extractTextAndDetectErrors(config) {
                const base64Image = await this.convertImageToBase64(this.state.uploadedImage);
                
                const prompt = `Extract ALL visible text(very very  must be exact spelling as the image ) from this image and analyze it for errors. Return a JSON response in this exact format:

{
  "extracted_text": "the complete text exactly as it appears",
  "issues": [
    {
      "type": "spelling",
      "original": "misspelled word",
      "suggested": "correct word",
      "description": "explanation of the issue",
      "source": "AI"
    },
    {
      "type": "decimal",
      "original": "1,5",
      "suggested": "1.5", 
      "description": "decimal comma should be decimal point",
      "source": "AI"
    }
  ]
}

RULES:
1. Extract text exactly as written (preserve original formatting)
2. Find spelling mistakes and suggest corrections
3. Find decimal comma errors (like 1,5 should be 1.5) and convert to decimal points
4. Only return valid JSON, no other text
5. If no issues found, return empty issues array
6. Focus on obvious errors - don't be overly aggressive`;

                const response = await this.callLLM(config, [
                    { type: "text", text: prompt },
                    { type: "image_url", image_url: { url: base64Image, detail: "high" } }
                ]);

                try {
                    // Extract JSON from response
                    const jsonMatch = response.match(/\{[\s\S]*\}/);
                    if (!jsonMatch) {
                        throw new Error('No valid JSON found in AI response');
                    }

                    const result = JSON.parse(jsonMatch[0]);
                    
                    if (!result.extracted_text) {
                        throw new Error('No extracted text found in AI response');
                    }

                    return {
                        text: result.extracted_text,
                        issues: Array.isArray(result.issues) ? result.issues : []
                    };

                } catch (error) {
                    console.warn('Failed to parse AI response, falling back to basic extraction:', error);
                    
                    // Fallback: treat entire response as text and do manual analysis
                    return {
                        text: response.trim(),
                        issues: []
                    };
                }
            }

            // Typo.js validation for additional spell checking
            validateWithTypoJS(text) {
                if (!this.dictionary || !text?.trim()) return [];

                const issues = [];
                const words = text.split(/\s+/);
                
                words.forEach((word, index) => {
                    if (!word.trim()) return;

                    const cleanWord = word.replace(/[^\w]/g, '').toLowerCase();
                    if (cleanWord.length > 2 && !/^\d+$/.test(cleanWord)) {
                        // Skip common patterns that might not be in dictionary
                        const skipPatterns = [
                            /^[A-Z]{2,}$/,           // Acronyms
                            /^\d+[A-Z]+$/,          // Alphanumeric codes
                            /^[A-Z]+\d+$/,          // Codes with numbers
                            /^www\./,               // URLs
                            /\.com$/,               // Domains
                            /^\w+@\w+\./            // Emails
                        ];
                        
                        const originalWord = word.replace(/[^\w]/g, '');
                        const shouldSkip = skipPatterns.some(pattern => pattern.test(originalWord));
                        
                        if (!shouldSkip && !this.dictionary.check(cleanWord)) {
                            const suggestions = this.dictionary.suggest(cleanWord);
                            if (suggestions?.length > 0) {
                                issues.push({
                                    type: 'spelling',
                                    original: word,
                                    suggested: word.replace(new RegExp(cleanWord, 'i'), suggestions[0]),
                                    position: index,
                                    description: 'Potential spelling error detected by Typo.js',
                                    source: 'Typo.js'
                                });
                            }
                        }
                    }
                });

                return issues;
            }

            // Merge AI and Typo.js issues, removing duplicates
            mergeIssues(aiIssues, typoIssues) {
                const merged = [...aiIssues];
                
                // Add Typo.js issues that aren't already found by AI
                typoIssues.forEach(typoIssue => {
                    const isDuplicate = aiIssues.some(aiIssue => {
                        return aiIssue.original.toLowerCase() === typoIssue.original.toLowerCase() &&
                               aiIssue.type === typoIssue.type;
                    });
                    
                    if (!isDuplicate) {
                        merged.push(typoIssue);
                    }
                });

                // Sort by position if available, otherwise by type
                return merged.sort((a, b) => {
                    if (a.position !== undefined && b.position !== undefined) {
                        return a.position - b.position;
                    }
                    return a.type.localeCompare(b.type);
                });
            }

            async callLLM(config, content) {
                const response = await fetch(`${config.baseUrl}/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: this.state.currentModel,
                        messages: [{ role: "user", content }],
                        temperature: 0.1 // Low temperature for consistent results
                    })
                });

                if (!response.ok) throw new Error(`LLM API failed: ${response.status}`);
                
                const data = await response.json();
                return data.choices[0].message.content;
            }

            convertImageToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            displayResults() {
                this.showElements(this.elements.resultsContainer);

                const { extractedText, detectedIssues } = this.state;
                
                let html = `
                    <div class="mb-4">
                        <h6 class="fw-bold"><i class="bi bi-file-text me-2"></i>Extracted Text:</h6>
                        <div class="p-3 border rounded  font-monospace" style="white-space: pre-wrap; max-height: 200px; overflow-y: auto;">${extractedText}</div>
                    </div>
                    <div><h6 class="fw-bold"><i class="bi bi-exclamation-triangle me-2"></i>Issues Found:</h6>
                `;

                if (detectedIssues.length === 0) {
                    html += '<div class="alert alert-success"><i class="bi bi-check-circle me-2"></i>No issues found! üéâ</div>';
                } else {
                    html += `<div class="alert alert-warning"><i class="bi bi-exclamation-triangle me-2"></i>${detectedIssues.length} issue(s) found using AI + Typo.js validation</div>`;
                    
                    detectedIssues.forEach((issue, index) => {
                        const badgeClass = issue.type === 'spelling' ? 'bg-warning' : 'bg-info';
                        const sourceBadge = issue.source === 'AI' ? 'bg-primary' : 'bg-secondary';
                        html += `
                            <div class="border rounded p-3 mb-2">
                            <div class="border rounded p-3 mb-2">
                                <div class="d-flex justify-content-between align-items-center mb-2">
                                    <div>
                                        <span class="badge ${badgeClass} me-2">${issue.type.toUpperCase()}</span>
                                        <span class="badge ${sourceBadge}">${issue.source}</span>
                                    </div>
                                </div>
                                <div>
                                    <strong class="text-danger">"${issue.original}"</strong> 
                                    <i class="bi bi-arrow-right mx-2"></i> 
                                    <em class="text-success">"${issue.suggested}"</em>
                                </div>
                                <small class="text-muted d-block mt-1">${issue.description}</small>
                            </div>
                        `;
                    });
                }

                html += '</div>';
                this.elements.resultsContent.innerHTML = html;
            }

            // Modal management
            showProgressModal() {
                this.progressModal = new bootstrap.Modal(document.getElementById('progressModal'));
                this.progressModal.show();
            }

            // FIXED: Enhanced modal hiding with proper cleanup
            hideProgressModal() {
                try {
                    // Hide the modal instance if it exists
                    if (this.progressModal) {
                        this.progressModal.hide();
                        this.progressModal = null;
                    }

                    // Also try to get and hide any existing modal instance
                    const existingModal = bootstrap.Modal.getInstance(document.getElementById('progressModal'));
                    if (existingModal) {
                        existingModal.hide();
                    }

                    // Force cleanup after a short delay
                    setTimeout(() => {
                        // Remove any remaining backdrops
                        const backdrops = document.querySelectorAll('.modal-backdrop');
                        backdrops.forEach(backdrop => backdrop.remove());
                        
                        // Reset body classes and styles
                        document.body.classList.remove('modal-open');
                        document.body.style.paddingRight = '';
                        document.body.style.overflow = '';
                        
                        // Reset modal state
                        const modalElement = document.getElementById('progressModal');
                        if (modalElement) {
                            modalElement.classList.remove('show');
                            modalElement.style.display = 'none';
                            modalElement.setAttribute('aria-hidden', 'true');
                            modalElement.removeAttribute('aria-modal');
                        }
                    }, 200);
                } catch (error) {
                    console.warn('Error hiding progress modal:', error);
                    // Force cleanup anyway
                    setTimeout(() => {
                        document.querySelectorAll('.modal-backdrop').forEach(backdrop => backdrop.remove());
                        document.body.classList.remove('modal-open');
                        document.body.style = '';
                    }, 100);
                }
            }

            updateProgress(text) {
                this.elements.progressText.textContent = text;
            }

            showNextCorrection() {
                const { detectedIssues, currentIssueIndex, acceptedCorrections } = this.state;
                
                if (currentIssueIndex >= detectedIssues.length) {
                    this.showElements(this.elements.downloadBtn);
                    this.showAlert(`Review complete! ${acceptedCorrections.length} correction(s) accepted.`, 'success');
                    return;
                }

                const issue = detectedIssues[currentIssueIndex];
                this.elements.originalText.textContent = issue.original;
                this.elements.suggestedText.textContent = issue.suggested;
                this.elements.issueType.textContent = issue.type.toUpperCase();
                this.elements.issueSource.textContent = issue.source || 'AI';
                this.elements.issueDescription.textContent = issue.description;

                const modal = new bootstrap.Modal(document.getElementById('correctionModal'));
                modal.show();
            }

            acceptCorrection() {
                this.state.acceptedCorrections.push(this.state.detectedIssues[this.state.currentIssueIndex]);
                this.hideModalAndContinue();
            }

            rejectCorrection() {
                this.hideModalAndContinue();
            }

            hideModalAndContinue() {
                const modal = bootstrap.Modal.getInstance(document.getElementById('correctionModal'));
                if (modal) modal.hide();
                
                this.state.currentIssueIndex++;
                setTimeout(() => this.showNextCorrection(), 300);
            }

            // PDF Generation with Interactive Comments - FIXED PROGRESS MODAL
            async downloadPDF() {
                this.setButtonState(this.elements.downloadBtn, true, 'Generating PDF...');
                this.showProgressModal();

                try {
                    // Convert image to proper format for PDF-lib
                    this.updateProgress('Processing image...');
                    const processedImageData = await this.convertImageForPDFLib();
                    
                    this.updateProgress('Creating PDF with interactive comments...');
                    const pdfBytes = await this.createPDFWithComments(processedImageData);
                    
                    this.updateProgress('Finalizing PDF...');
                    
                    // Download the PDF
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = this.generateFilename();
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // FIXED: Hide progress modal BEFORE showing success alert
                    this.hideProgressModal();
                    
                    this.showAlert('Interactive PDF with comments generated successfully! Click comment icons to see corrections. üìÑ‚úÖ', 'success');
                    
                } catch (error) {
                    console.error('PDF generation error:', error);
                    this.hideProgressModal();
                    this.showAlert(`PDF generation failed: ${error.message}`, 'danger');
                } finally {
                    this.setButtonState(this.elements.downloadBtn, false, '<i class="bi bi-download me-2"></i>Download Interactive PDF');
                }
            }

            // FIXED: Proper image conversion for PDF-lib
            async convertImageForPDFLib() {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        try {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            canvas.width = img.width;
                            canvas.height = img.height;
                            
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(img, 0, 0);
                            
                            canvas.toBlob(blob => {
                                if (!blob) {
                                    reject(new Error('Failed to create image blob'));
                                    return;
                                }
                                
                                const reader = new FileReader();
                                reader.onload = () => {
                                    const arrayBuffer = reader.result;
                                    resolve(new Uint8Array(arrayBuffer));
                                };
                                reader.onerror = () => reject(new Error('Failed to read image blob'));
                                reader.readAsArrayBuffer(blob);
                            }, 'image/jpeg', 0.9);
                            
                        } catch (error) {
                            reject(new Error(`Canvas processing failed: ${error.message}`));
                        }
                    };
                    
                    img.onerror = () => reject(new Error('Failed to load image'));
                    
                    if (this.state.originalImageBase64) {
                        img.src = this.state.originalImageBase64;
                    } else {
                        const reader = new FileReader();
                        reader.onload = e => img.src = e.target.result;
                        reader.onerror = () => reject(new Error('Failed to read uploaded file'));
                        reader.readAsDataURL(this.state.uploadedImage);
                    }
                });
            }

            async createPDFWithComments(imageBytes) {
                // FIXED: Properly destructure ALL required functions from PDFLib
                const { PDFDocument, PDFName, PDFNumber, PDFString, rgb } = PDFLib;
                
                try {
                    const pdfDoc = await PDFDocument.create();
                    
                    let image;
                    try {
                        image = await pdfDoc.embedJpg(imageBytes);
                    } catch (jpgError) {
                        console.warn('JPG embedding failed, trying PNG:', jpgError);
                        image = await pdfDoc.embedPng(imageBytes);
                    }
                    
                    const page = pdfDoc.addPage();
                    const { width: pageWidth, height: pageHeight } = page.getSize();
                    
                    const imageLayout = this.calculateImageLayout(image.width, image.height, pageWidth, pageHeight);
                    
                    // Draw image on page
                    page.drawImage(image, {
                        x: imageLayout.x,
                        y: imageLayout.y,
                        width: imageLayout.width,
                        height: imageLayout.height,
                    });

                    // FIXED: Sanitize all text for PDF compatibility
                    const titleText = this.sanitizeTextForPDF('OCR Analysis Report with Interactive Comments');
                    const subtitleText = this.sanitizeTextForPDF('Click on comment icons to see error corrections');

                    // Add title
                    page.drawText(titleText, {
                        x: 50,
                        y: pageHeight - 40,
                        size: 16,
                        color: rgb(0, 0, 0),
                    });

                    // Add subtitle
                    page.drawText(subtitleText, {
                        x: 50,
                        y: pageHeight - 65,
                        size: 10,
                        color: rgb(0.5, 0.5, 0.5),
                    });

                    // Add interactive comments - now without numbers
                    await this.addInteractiveComments(pdfDoc, page, imageLayout, { PDFName, PDFNumber, PDFString, rgb });

                    // Add summary text - now with proper encoding
                    this.addSummaryText(page, imageLayout, pageHeight, rgb);

                    return await pdfDoc.save();
                    
                } catch (error) {
                    throw new Error(`PDF creation failed: ${error.message}`);
                }
            }

            // FIXED: Remove numbers from comments as requested
            async addInteractiveComments(pdfDoc, page, imageLayout, { PDFName, PDFNumber, PDFString, rgb }) {
                const { acceptedCorrections } = this.state;
                
                if (acceptedCorrections.length === 0) return;

                const ctx = pdfDoc.context;

                // Get or create annotations array
                let annots = page.node.lookup(PDFName.of("Annots"));
                if (!annots) {
                    annots = ctx.obj([]);
                    page.node.set(PDFName.of("Annots"), annots);
                }

                // Add comment for each correction
                acceptedCorrections.forEach((correction, index) => {
                    try {
                        const x = imageLayout.x + imageLayout.width + 20;
                        const y = imageLayout.y + imageLayout.height - (index * 60) - 50;
                        
                        const iconSize = 20;
                        const popupWidth = 300;
                        const popupHeight = 100;

                        // FIXED: Remove numbers from comment text as requested
                        const sanitizedOriginal = this.sanitizeTextForPDF(correction.original);
                        const sanitizedSuggested = this.sanitizeTextForPDF(correction.suggested);
                        const sanitizedDescription = this.sanitizeTextForPDF(correction.description);
                        const sanitizedSource = this.sanitizeTextForPDF(correction.source || 'AI');

                        const commentText = `${correction.type.toUpperCase()} Error (${sanitizedSource}):\n\n` +
                                           `Original: "${sanitizedOriginal}"\n` +
                                           `Corrected: "${sanitizedSuggested}"\n\n` +
                                           `Description: ${sanitizedDescription}`;

                        const safeX = Math.max(20, Math.min(x, page.getSize().width - iconSize - 5));
                        const safeY = Math.max(50, Math.min(y, page.getSize().height - 50));

                        const iconRect = [safeX, safeY, safeX + iconSize, safeY + iconSize];
                        const popupRect = [
                            Math.max(20, safeX - popupWidth - 10),
                            safeY - popupHeight + iconSize,
                            safeX - 10,
                            safeY + iconSize,
                        ];

                        const popupAnnot = ctx.obj({
                            Type: PDFName.of("Annot"),
                            Subtype: PDFName.of("Popup"),
                            Rect: ctx.obj(popupRect.map(PDFNumber.of)),
                            Open: false,
                        });

                        const textAnnot = ctx.obj({
                            Type: PDFName.of("Annot"),
                            Subtype: PDFName.of("Text"),
                            Rect: ctx.obj(iconRect.map(PDFNumber.of)),
                            Contents: PDFString.of(commentText),
                            T: PDFString.of('OCR Checker'),
                            C: ctx.obj(correction.type === 'spelling' ? 
                                [PDFNumber.of(1), PDFNumber.of(0.8), PDFNumber.of(0)] : 
                                [PDFNumber.of(0), PDFNumber.of(0.8), PDFNumber.of(1)]
                            ),
                            Name: PDFName.of("Comment"),
                            M: PDFString.of(new Date().toISOString()),
                            Open: false,
                            Popup: popupAnnot,
                        });

                        annots.push(textAnnot);
                        annots.push(popupAnnot);

                        // REMOVED: Comment numbers next to icons as requested
                        // No more page.drawText with numbers

                    } catch (annotError) {
                        console.warn(`Failed to create annotation ${index + 1}:`, annotError);
                    }
                });
            }

            // FIXED: Sanitize all text content for summary
            addSummaryText(page, imageLayout, pageHeight, rgb) {
                const { acceptedCorrections } = this.state;
                let yPos = imageLayout.y - 40;

                const summaryTitle = this.sanitizeTextForPDF('Corrections Summary:');
                page.drawText(summaryTitle, {
                    x: 50,
                    y: yPos,
                    size: 14,
                    color: rgb(0, 0, 0),
                });

                if (acceptedCorrections.length === 0) {
                    const noErrorsText = this.sanitizeTextForPDF('OK No corrections needed - text appears to be error-free!');
                    page.drawText(noErrorsText, {
                        x: 50,
                        y: yPos - 25,
                        size: 12,
                        color: rgb(0, 0.6, 0),
                    });
                } else {
                    yPos -= 25;
                    const summaryText = this.sanitizeTextForPDF(`${acceptedCorrections.length} correction(s) made. Click comment icons above for details.`);
                    page.drawText(summaryText, {
                        x: 50,
                        y: yPos,
                        size: 12,
                        color: rgb(0.3, 0.3, 0.3),
                    });

                    acceptedCorrections.slice(0, 5).forEach((correction, index) => {
                        yPos -= 20;
                        const sanitizedOriginal = this.sanitizeTextForPDF(correction.original);
                        const sanitizedSuggested = this.sanitizeTextForPDF(correction.suggested);
                        
                        const text = `"${sanitizedOriginal}" -> "${sanitizedSuggested}" (${correction.type})`;
                        const truncatedText = text.substring(0, 80) + (text.length > 80 ? '...' : '');
                        
                        page.drawText(truncatedText, {
                            x: 60,
                            y: yPos,
                            size: 10,
                            color: rgb(0.2, 0.2, 0.2),
                        });
                    });

                    if (acceptedCorrections.length > 5) {
                        yPos -= 20;
                        const moreText = this.sanitizeTextForPDF(`... and ${acceptedCorrections.length - 5} more (see comments above)`);
                        page.drawText(moreText, {
                            x: 60,
                            y: yPos,
                            size: 10,
                            color: rgb(0.5, 0.5, 0.5),
                        });
                    }
                }

                // Footer
                const footerText = this.sanitizeTextForPDF(`Generated: ${new Date().toLocaleString()} | OCR Checker v1.0`);
                page.drawText(footerText, {
                    x: 50,
                    y: 30,
                    size: 8,
                    color: rgb(0.6, 0.6, 0.6),
                });
            }

            calculateImageLayout(imageWidth, imageHeight, pageWidth, pageHeight) {
                const margin = 50;
                const availableWidth = pageWidth - (margin * 2) - 100;
                const availableHeight = pageHeight - 150;
                
                let width = imageWidth;
                let height = imageHeight;
                const aspectRatio = imageWidth / imageHeight;
                
                if (width > availableWidth) {
                    width = availableWidth;
                    height = width / aspectRatio;
                }
                if (height > availableHeight) {
                    height = availableHeight;
                    width = height * aspectRatio;
                }
                
                return {
                    x: margin,
                    y: pageHeight - height - 120,
                    width,
                    height
                };
            }

            generateFilename() {
                const originalName = this.state.uploadedImage.name;
                const nameWithoutExt = originalName.substring(0, originalName.lastIndexOf('.')) || originalName;
                return `${nameWithoutExt}_OCR_Interactive_Report.pdf`;
            }

            resetApp() {
                // Reset state
                this.state = {
                    uploadedImage: null,
                    extractedText: '',
                    detectedIssues: [],
                    acceptedCorrections: [],
                    currentIssueIndex: 0,
                    originalImageBase64: null,
                    currentModel: this.state.currentModel
                };

                // Reset UI
                this.hideElements(
                    this.elements.previewContainer, 
                    this.elements.resultsContainer, 
                    this.elements.downloadBtn, 
                    this.elements.newProcessBtn
                );
                
                this.elements.processBtn.disabled = true;
                this.elements.imageInput.value = '';
                this.elements.dropArea.innerHTML = `
                    <i class="bi bi-cloud-upload fs-1 text-muted"></i>
                    <p class="mt-3 mb-2 h5">Drag and drop an image here or click to browse</p>
                    <p class="text-muted small">Supported formats: BMP, GIF, TIFF, JPEG, PNG, EPS, WEBP</p>
                `;

                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.ocrApp = new OCRSpellChecker();
        });
    </script>
</body>
</html>